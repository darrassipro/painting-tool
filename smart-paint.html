<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <title>UltraSmart Paint Pro</title>
  <meta name="viewport" content="width=device-width,initial-scale=1"/>
  <style>
    body { 
      background: #25273c; 
      margin: 0; 
      padding: 0; 
      font-family: 'Segoe UI', Arial, sans-serif; 
      color: #f5f5f7;
      overflow-x: hidden;
      min-height: 100vh;
    }
    
    .toolbar { 
      background: #171a26; 
      padding: 10px 5px; 
      display: flex; 
      gap: 6px; 
      align-items: center; 
      box-shadow: 0 2px 12px #15162860; 
      border-bottom: 1px solid #2e3151;
      flex-wrap: wrap;
      position: relative;
      z-index: 100;
      justify-content: flex-start;
    }
    
    .btn { 
      background: #282d44; 
      border: none; 
      color: #fff; 
      font-size: 0.9em; 
      padding: 8px 12px; 
      border-radius: 6px; 
      cursor: pointer; 
      margin: 2px; 
      transition: all .13s; 
      outline: none;
      position: relative;
      min-height: 40px;
      min-width: 40px;
      display: flex;
      align-items: center;
      justify-content: center;
      white-space: nowrap;
      user-select: none;
      -webkit-user-select: none;
      -webkit-tap-highlight-color: transparent;
    }
    
    .btn.active, .btn:focus { 
      background: #4960ff; 
      box-shadow: 0 0 0 2px #4960ff40;
    }
    
    .btn:disabled {
      background: #333951; 
      color: #a9a9c2;
      cursor: not-allowed;
    }
    
    .btn:hover:not(:disabled) {
      background: #3a4266;
      transform: translateY(-1px);
    }
    
    .btn:active {
      transform: translateY(0);
    }
    
    .color-picker { 
      width: 40px; 
      height: 40px; 
      border: none; 
      border-radius: 50%; 
      margin: 0 5px;
      cursor: pointer;
      box-shadow: 0 2px 8px rgba(0,0,0,0.3);
    }
    
    .range { 
      margin: 0 6px;
      accent-color: #4960ff;
      min-width: 80px;
    }
    
    #size-val {
      min-width: 35px;
      font-size: 0.85em;
      color: #b2bbda;
    }
    
    #canvas-wrap { 
      display: flex; 
      justify-content: center; 
      align-items: center; 
      background: #28305a; 
      min-height: calc(100vh - 120px);
      position: relative;
      padding: 10px;
    }
    
    #paint-canvas { 
      background: #fff; 
      border-radius: 10px; 
      box-shadow: 0 5px 50px 0 #191a2180; 
      border: 2px solid #23253A; 
      cursor: crosshair; 
      display: block;
      max-width: 100%;
      max-height: 80vh;
      touch-action: none;
    }
    
    #paint-canvas.selection-on { 
      box-shadow: 0 0 0 3px #00ffbb, 0 6px 30px #1e1d2f66;
      animation: selectionPulse 2s infinite;
    }
    
    @keyframes selectionPulse {
      0%, 100% { box-shadow: 0 0 0 3px #00ffbb, 0 6px 30px #1e1d2f66; }
      50% { box-shadow: 0 0 0 5px #00ffbb80, 0 6px 30px #1e1d2f66; }
    }
    
    /* Selection overlay styling */
    .selection-overlay {
      position: absolute;
      pointer-events: none;
      border: 2px dashed #00ffbb;
      animation: marchingAnts 1s linear infinite;
      z-index: 10;
    }
    
    @keyframes marchingAnts {
      0% { border-offset: 0; }
      100% { border-offset: 8px; }
    }
    
    .footer { 
      text-align: center; 
      color: #b2bbda; 
      font-size: .85em; 
      margin: 8px 0 0 0; 
      padding: 8px;
    }
    
    .smart-tip { 
      background: #1e2130; 
      color: #b3ffe4; 
      border-radius: 9px; 
      padding: 8px 16px; 
      position: absolute; 
      left: 50%; 
      top: 15px; 
      transform: translateX(-50%); 
      font-size: 0.9em; 
      box-shadow: 0 4px 20px #0c0e2190; 
      z-index: 999; 
      display: none;
      max-width: 90%;
      text-align: center;
      animation: tipSlideIn 0.3s ease;
    }
    
    @keyframes tipSlideIn {
      from { opacity: 0; transform: translateX(-50%) translateY(-10px); }
      to { opacity: 1; transform: translateX(-50%) translateY(0); }
    }
    
    .show-tip { 
      display: block;
    }
    
    .palette { 
      display: inline-flex; 
      margin-left: 8px; 
      gap: 3px;
      flex-wrap: wrap;
    }
    
    .palette div { 
      width: 16px;
      height: 16px;
      display: inline-block;
      border-radius: 4px;
      cursor: pointer;
      border: 1px solid #2e304d;
      transition: all 0.2s;
    }
    
    .palette div:hover {
      transform: scale(1.1);
      border-color: #4960ff;
    }
    
    .palette div.selected { 
      border: 2px solid #09e9c6;
      transform: scale(1.15);
    }
    
    #magicWandBtn.active { 
      background: #09e9c6;
      color: #213;
    }
    
    #ai-panel {
      position: fixed;
      top: 70px; 
      right: 10px;
      background: #1a1c2e;
      color: #eafff8;
      border: 1px solid #2e3151;
      border-radius: 11px;
      padding: 15px 20px;
      min-width: 280px;
      max-width: 380px;
      z-index: 205;
      box-shadow: 0 7px 30px #0009;
      display: none;
      font-size: 1em;
      max-height: 80vh;
      overflow-y: auto;
    }
    
    #ai-panel h3 { 
      margin: 0 0 12px 0; 
      font-size: 1.1em; 
      color: #b1f8e9;
      border-bottom: 1px solid #2e3151;
      padding-bottom: 8px;
    }
    
    .ai-row { 
      margin-bottom: 12px;
      padding: 8px;
      background: #232538;
      border-radius: 6px;
    }
    
    .ai-row label { 
      display: block;
      margin-bottom: 6px;
      font-weight: 600;
      color: #b1f8e9;
      font-size: 0.9em;
    }
    
    .ai-slider { 
      width: 100px;
      margin-right: 8px;
    }
    
    .ai-btn {
      background: #26d6a0; 
      color: #183;
      padding: 6px 12px;
      border-radius: 5px; 
      border: none;
      font-size: 0.85em; 
      font-weight: 600;
      cursor: pointer; 
      transition: all .13s;
      margin: 2px;
      min-height: 32px;
    }
    
    .ai-btn:hover { 
      background: #51ffc9;
      transform: translateY(-1px);
    }
    
    .close-ai { 
      position: absolute; 
      top: 8px; 
      right: 12px; 
      color: #eee; 
      background: none; 
      border: none; 
      font-size: 1.1em; 
      cursor: pointer;
      width: 24px;
      height: 24px;
      display: flex;
      align-items: center;
      justify-content: center;
      border-radius: 4px;
    }
    
    .close-ai:hover {
      background: #ff4757;
      color: white;
    }
    
    .ai-tip { 
      font-size: .8em; 
      color: #bce9ff; 
      margin-top: 4px;
      font-style: italic;
    }
    
    .tooltip {
      position: absolute;
      background: #000;
      color: white;
      padding: 4px 8px;
      border-radius: 4px;
      font-size: 0.8em;
      pointer-events: none;
      z-index: 1000;
      opacity: 0;
      transition: opacity 0.3s;
      white-space: nowrap;
    }
    
    .tooltip.show {
      opacity: 1;
    }
    
    .loading-spinner {
      position: absolute;
      top: 50%;
      left: 50%;
      transform: translate(-50%, -50%);
      width: 40px;
      height: 40px;
      border: 3px solid #2e3151;
      border-top: 3px solid #4960ff;
      border-radius: 50%;
      animation: spin 1s linear infinite;
      z-index: 1000;
      display: none;
    }
    
    @keyframes spin {
      0% { transform: translate(-50%, -50%) rotate(0deg); }
      100% { transform: translate(-50%, -50%) rotate(360deg); }
    }
    
    .onboarding-modal {
      position: fixed;
      top: 0;
      left: 0;
      width: 100%;
      height: 100%;
      background: rgba(0, 0, 0, 0.8);
      display: flex;
      align-items: center;
      justify-content: center;
      z-index: 10000;
      font-family: 'Segoe UI', Arial, sans-serif;
      padding: 20px;
      box-sizing: border-box;
    }
    
    .onboarding-content {
      background: #1a1c2e;
      border-radius: 15px;
      padding: 25px;
      max-width: 600px;
      max-height: 80vh;
      overflow-y: auto;
      color: #eafff8;
      box-shadow: 0 10px 50px rgba(0, 0, 0, 0.5);
      width: 100%;
      box-sizing: border-box;
    }
    
    .onboarding-content h2 {
      color: #b1f8e9;
      margin-bottom: 15px;
      font-size: 1.5em;
    }
    
    .feature-grid {
      display: grid;
      grid-template-columns: repeat(auto-fit, minmax(200px, 1fr));
      gap: 12px;
      margin: 15px 0;
    }
    
    .feature-item {
      background: #232538;
      padding: 12px;
      border-radius: 6px;
      border-left: 3px solid #4960ff;
    }
    
    .feature-item h4 {
      color: #b1f8e9;
      margin: 0 0 6px 0;
      font-size: 1em;
    }
    
    .feature-item p {
      margin: 0;
      font-size: 0.85em;
      color: #bce9ff;
    }
    
    .onboarding-close {
      background: #26d6a0;
      color: #183;
      border: none;
      padding: 10px 20px;
      border-radius: 6px;
      font-size: 0.9em;
      font-weight: 600;
      cursor: pointer;
      margin-top: 15px;
      float: right;
    }
    
    .canvas-controls {
      position: absolute;
      top: 8px;
      right: 8px;
      display: flex;
      gap: 4px;
      z-index: 50;
      flex-wrap: wrap;
    }
    
    .canvas-controls .btn {
      padding: 6px 8px;
      font-size: 0.8em;
      min-width: 35px;
      min-height: 35px;
    }
    
    .progress-bar {
      position: fixed;
      top: 0;
      left: 0;
      width: 0%;
      height: 3px;
      background: #4960ff;
      z-index: 10001;
      transition: width 0.3s;
    }

    /* Mobile Responsiveness */
    @media (max-width: 480px) {
      .toolbar {
        padding: 8px 4px;
        gap: 4px;
        justify-content: center;
      }
      
      .btn {
        padding: 10px 8px;
        margin: 1px;
        font-size: 0.8em;
        min-height: 44px;
        min-width: 44px;
      }
      
      .color-picker {
        width: 44px;
        height: 44px;
        margin: 0 3px;
      }
      
      .range {
        min-width: 60px;
        margin: 0 4px;
      }
      
      #size-val {
        font-size: 0.8em;
        min-width: 30px;
      }
      
      #canvas-wrap {
        padding: 5px;
        min-height: calc(100vh - 140px);
      }
      
      #paint-canvas {
        width: 95vw !important;
        height: auto !important;
        max-height: 60vh;
        border-radius: 8px;
      }
      
      #ai-panel {
        left: 5px;
        right: 5px;
        min-width: 0;
        width: calc(100vw - 10px);
        top: 80px;
        max-height: 70vh;
        padding: 12px 15px;
      }
      
      .ai-btn {
        padding: 8px 10px;
        font-size: 0.8em;
        margin: 1px;
        min-height: 36px;
      }
      
      .palette {
        margin-left: 4px;
        gap: 2px;
      }
      
      .palette div {
        width: 14px;
        height: 14px;
      }
      
      .smart-tip {
        font-size: 0.8em;
        padding: 6px 12px;
        top: 10px;
        max-width: 95%;
      }
      
      .canvas-controls {
        top: 5px;
        right: 5px;
        gap: 2px;
      }
      
      .canvas-controls .btn {
        min-width: 32px;
        min-height: 32px;
        padding: 4px 6px;
        font-size: 0.75em;
      }
      
      .footer {
        font-size: 0.75em;
        padding: 6px;
      }
      
      .onboarding-content {
        padding: 15px;
        margin: 10px;
      }
      
      .onboarding-content h2 {
        font-size: 1.3em;
      }
      
      .feature-grid {
        grid-template-columns: 1fr;
        gap: 8px;
      }
    }
    
    @media (max-width: 768px) and (min-width: 481px) {
      .toolbar {
        padding: 8px 6px;
        gap: 5px;
      }
      
      .btn {
        padding: 9px 10px;
        min-height: 42px;
        min-width: 42px;
      }
      
      .color-picker {
        width: 42px;
        height: 42px;
      }
      
      #paint-canvas {
        width: 90vw !important;
        height: auto !important;
        max-height: 65vh;
      }
      
      #ai-panel {
        left: 8px;
        right: 8px;
        width: calc(100vw - 16px);
        top: 75px;
        max-height: 75vh;
      }
      
      .canvas-controls .btn {
        min-width: 36px;
        min-height: 36px;
      }
    }
    
    /* Landscape mobile orientation */
    @media (max-width: 768px) and (orientation: landscape) {
      #canvas-wrap {
        min-height: calc(100vh - 100px);
      }
      
      #paint-canvas {
        max-height: 70vh;
      }
      
      #ai-panel {
        max-height: 60vh;
        top: 60px;
      }
    }
    
    /* Touch improvements */
    @media (hover: none) and (pointer: coarse) {
      .btn:hover {
        transform: none;
        background: #3a4266;
      }
      
      .btn:active {
        background: #4960ff;
        transform: scale(0.95);
      }
      
      .palette div:hover {
        transform: none;
      }
      
      .palette div:active {
        transform: scale(1.1);
      }
    }
  </style>
</head>
<body>
  <div class="progress-bar" id="progress-bar"></div>
  
  <div class="toolbar">
    <button class="btn" id="tool-brush" data-tooltip="Brush Tool (B)">üñåÔ∏è</button>
    <button class="btn" id="tool-eraser" data-tooltip="Eraser Tool (E)">üßπ</button>
    <button class="btn" id="tool-fill" data-tooltip="Smart Fill Tool (F)">üé®</button>
    <button class="btn" id="magicWandBtn" data-tooltip="Magic Wand Selection (W)">‚≠ê</button>
    <input type="color" id="color" class="color-picker" data-tooltip="Color Picker"/>
    <input type="range" min="1" max="100" value="10" id="size" class="range" data-tooltip="Brush Size"/>
    <span id="size-val" style="min-width:25px;">10px</span>
    <span id="harmonies" class="palette"></span>
    <button class="btn" id="undo" data-tooltip="Undo (Ctrl+Z)">‚Ü∂</button>
    <button class="btn" id="redo" data-tooltip="Redo (Ctrl+Y)">‚Ü∑</button>
    <button class="btn" id="clear" data-tooltip="Clear Canvas">üóëÔ∏è</button>
    <input type="file" id="import" accept="image/*" style="display:none">
    <button class="btn" id="import-btn" data-tooltip="Import Image">üì∑</button>
    <button class="btn" id="save" data-tooltip="Save Image">üíæ</button>
    <button class="btn" id="autoEnhanceBtn" data-tooltip="Auto Enhance Image">‚ú®</button>
    <button class="btn" id="removeBgBtn" data-tooltip="Remove Background">üß¨</button>
    <button class="btn" id="showAIPanelBtn" style="background:#1a1c2e;font-weight:bold;color:#85ffdc;" data-tooltip="AI Tools Panel">üß† AI</button>
    <span style="flex:1"></span>
    <button class="btn" id="fitToScreen" data-tooltip="Fit to Screen">üîç</button>
    <span id="tipBtn" class="btn" style="font-size:18px;" data-tooltip="Smart Tips">üí°</span>
  </div>
  
  <div id="canvas-wrap" style="position:relative;">
    <div class="canvas-controls">
      <button class="btn" id="zoomIn" data-tooltip="Zoom In">üîç+</button>
      <button class="btn" id="zoomOut" data-tooltip="Zoom Out">üîç-</button>
      <button class="btn" id="resetZoom" data-tooltip="Reset Zoom">1:1</button>
    </div>
    <canvas id="paint-canvas" width="900" height="550"></canvas>
    <canvas id="selection-canvas" width="900" height="550" style="position: absolute; top: 0; left: 0; pointer-events: none; opacity: 0.7;"></canvas>
    <div class="smart-tip" id="smart-tip"></div>
    <div class="loading-spinner" id="loading-spinner"></div>
    
    <div id="ai-panel">
      <button class="close-ai" id="closeAIPanelBtn">‚úñ</button>
      <h3>üß† AI & Professional Tools</h3>
      
      <div class="ai-row">
        <label>üéØ Smart Selection</label>
        <button class="ai-btn" id="ai-edge">Edge Detect</button>
        <button class="ai-btn" id="ai-refine-btn">Refine Selection</button>
        <input type="range" id="ai-refine" class="ai-slider" min="-10" max="20" value="5"/>
        <span id="ai-refine-val">5</span>
        <div class="ai-tip">Detect edges and refine selections with precision</div>
      </div>
      
      <div class="ai-row">
        <label>üß¨ Content-Aware Tools</label>
        <button class="ai-btn" id="ai-inpaint">Remove Object</button>
        <button class="ai-btn" id="ai-patch">Patch Tool</button>
        <div class="ai-tip">Select with Magic Wand ‚≠ê, then remove or patch seamlessly</div>
      </div>
      
      <div class="ai-row">
        <label>üåà Smart Fill Options</label>
        <label style="font-size: 0.9em; margin-bottom: 4px;">Anti-aliasing:</label>
        <input type="range" id="ai-smooth" class="ai-slider" min="0" max="5" value="2"/>
        <span id="ai-smooth-val">2</span>
        <button class="ai-btn" id="ai-smooth-btn">Apply</button>
        <div class="ai-tip">Smooth edges for professional fills</div>
      </div>
      
      <div class="ai-row">
        <label>üé® Color & Style Enhancement</label>
        <button class="ai-btn" id="ai-colorize">Vivid Colors</button>
        <button class="ai-btn" id="ai-color-match">Color Harmony</button>
        <button class="ai-btn" id="ai-saturation">Boost Saturation</button>
        <div class="ai-tip">Bring your artwork to life with vibrant colors</div>
      </div>
      
      <div class="ai-row">
        <label>üí° Lighting Effects</label>
        <button class="ai-btn" id="ai-dodge">Dodge (Lighten)</button>
        <button class="ai-btn" id="ai-burn">Burn (Darken)</button>
        <button class="ai-btn" id="ai-dramatic">Dramatic Light</button>
        <div class="ai-tip">Professional lighting and vivid shading tools</div>
      </div>
      
      <div class="ai-row">
        <label>üé® Artistic Styles</label>
        <button class="ai-btn" id="ai-style-sketch">Sharp Sketch</button>
        <button class="ai-btn" id="ai-style-paint">Vivid Paint</button>
        <button class="ai-btn" id="ai-style-watercolor">Crystal Clear</button>
        <div class="ai-tip">Transform with crystal-clear, sharp artistic filters</div>
      </div>
      
      <div class="ai-row">
        <label>üîß Selective Adjustments</label>
        <button class="ai-btn" id="ai-contrast">Auto Contrast</button>
        <button class="ai-btn" id="ai-sharpen">Sharpen</button>
        <button class="ai-btn" id="ai-blur">Selective Blur</button>
        <div class="ai-tip">Apply adjustments to selected areas only</div>
      </div>
    </div>
  </div>
  
  <div class="footer">
    UltraSmart Paint Pro ‚Äî Professional Web Painting Suite by <a href="https://github.com/darrassipro" style="color:#7ea1ff;text-decoration:none;">@darrassipro</a>
  </div>
  
  <div class="tooltip" id="tooltip"></div>

  <script>
    // --- CORE STATE ---
    const canvas = document.getElementById("paint-canvas");
    const ctx = canvas.getContext("2d");
    const selectionCanvas = document.getElementById("selection-canvas");
    const selectionCtx = selectionCanvas.getContext("2d");
    
    let drawing = false;
    let tool = "brush";
    let color = "#09e9c6";
    let size = 10;
    let undoStack = [];
    let redoStack = [];
    let last = [0, 0];
    let fillTolerance = 32;
    let selectionMask = null;
    let selectionBounds = null;
    let canvasScale = 1;
    let canvasOffsetX = 0;
    let canvasOffsetY = 0;
    let isFirstVisit = !localStorage.getItem('paintProVisited');

    // Position selection canvas to match main canvas
    function updateSelectionCanvasPosition() {
      const canvasRect = canvas.getBoundingClientRect();
      const wrapRect = document.getElementById("canvas-wrap").getBoundingClientRect();
      
      selectionCanvas.style.left = (canvasRect.left - wrapRect.left) + "px";
      selectionCanvas.style.top = (canvasRect.top - wrapRect.top) + "px";
      selectionCanvas.style.width = canvas.style.width || canvas.width + "px";
      selectionCanvas.style.height = canvas.style.height || canvas.height + "px";
    }

    // --- PERCEPTUAL COLOR DISTANCE (LAB) ---
    function rgbToLab(r, g, b) {
      r = r / 255;
      g = g / 255;
      b = b / 255;
      
      r = r > 0.04045 ? Math.pow((r + 0.055) / 1.055, 2.4) : r / 12.92;
      g = g > 0.04045 ? Math.pow((g + 0.055) / 1.055, 2.4) : g / 12.92;
      b = b > 0.04045 ? Math.pow((b + 0.055) / 1.055, 2.4) : b / 12.92;
      
      let x = (r * 0.4124 + g * 0.3576 + b * 0.1805) / 0.95047;
      let y = (r * 0.2126 + g * 0.7152 + b * 0.0722) / 1.00000;
      let z = (r * 0.0193 + g * 0.1192 + b * 0.9505) / 1.08883;
      
      x = x > 0.008856 ? Math.pow(x, 1/3) : (7.787 * x) + 16/116;
      y = y > 0.008856 ? Math.pow(y, 1/3) : (7.787 * y) + 16/116;
      z = z > 0.008856 ? Math.pow(z, 1/3) : (7.787 * z) + 16/116;
      
      return [
        (116 * y) - 16,
        500 * (x - y),
        200 * (y - z)
      ];
    }

    function deltaE76(lab1, lab2) {
      const dL = lab1[0] - lab2[0];
      const da = lab1[1] - lab2[1];
      const db = lab1[2] - lab2[2];
      return Math.sqrt(dL * dL + da * da + db * db);
    }

    function perceptualColorDistance(r1, g1, b1, r2, g2, b2) {
      const lab1 = rgbToLab(r1, g1, b1);
      const lab2 = rgbToLab(r2, g2, b2);
      return deltaE76(lab1, lab2);
    }

    // --- UI Elements ---
    const colorInput = document.getElementById("color");
    const sizeInput = document.getElementById("size");
    const sizeVal = document.getElementById("size-val");
    const [toolBrush, toolEraser, toolFill, magicWandBtn] =
      ["tool-brush", "tool-eraser", "tool-fill", "magicWandBtn"].map(id => document.getElementById(id));
    const clearBtn = document.getElementById("clear");
    const saveBtn = document.getElementById("save");
    const undoBtn = document.getElementById("undo");
    const redoBtn = document.getElementById("redo");
    const importBtn = document.getElementById("import-btn");
    const importInput = document.getElementById("import");
    const tipBtn = document.getElementById("tipBtn");
    const tipPop = document.getElementById("smart-tip");
    const harmoniesDiv = document.getElementById("harmonies");
    const loadingSpinner = document.getElementById("loading-spinner");
    const progressBar = document.getElementById("progress-bar");
    const tooltip = document.getElementById("tooltip");

    // Canvas controls
    const zoomInBtn = document.getElementById("zoomIn");
    const zoomOutBtn = document.getElementById("zoomOut");
    const resetZoomBtn = document.getElementById("resetZoom");
    const fitToScreenBtn = document.getElementById("fitToScreen");

    // AI Panel
    const aiPanel = document.getElementById("ai-panel");
    document.getElementById("showAIPanelBtn").onclick = () => aiPanel.style.display = "block";
    document.getElementById("closeAIPanelBtn").onclick = () => aiPanel.style.display = "none";

    // --- TOOLTIP SYSTEM ---
    function initTooltips() {
      document.querySelectorAll('[data-tooltip]').forEach(element => {
        element.addEventListener('mouseenter', showTooltip);
        element.addEventListener('mouseleave', hideTooltip);
        
        // Touch devices - show tooltip on touch
        element.addEventListener('touchstart', function(e) {
          e.preventDefault();
          showTooltip.call(this, e);
          setTimeout(hideTooltip, 2000);
        }, { passive: false });
      });
    }

    function showTooltip(e) {
      const text = e.target.getAttribute('data-tooltip');
      tooltip.textContent = text;
      tooltip.classList.add('show');
      
      const rect = e.target.getBoundingClientRect();
      tooltip.style.left = Math.min(rect.left + rect.width / 2 - tooltip.offsetWidth / 2, window.innerWidth - tooltip.offsetWidth - 10) + 'px';
      tooltip.style.top = rect.bottom + 5 + 'px';
    }

    function hideTooltip() {
      tooltip.classList.remove('show');
    }

    // --- PROGRESS INDICATOR ---
    function showProgress(percent) {
      progressBar.style.width = percent + '%';
      if (percent >= 100) {
        setTimeout(() => progressBar.style.width = '0%', 500);
      }
    }

    function showLoading() {
      loadingSpinner.style.display = 'block';
    }

    function hideLoading() {
      loadingSpinner.style.display = 'none';
    }

    // --- ONBOARDING MODAL ---
    function showOnboarding() {
      if (isFirstVisit) {
        const modal = document.createElement('div');
        modal.className = 'onboarding-modal';
        modal.innerHTML = `
          <div class="onboarding-content">
            <h2>üé® Welcome to UltraSmart Paint Pro!</h2>
            <p>Your professional web-based painting suite with AI-powered tools.</p>
            
            <div class="feature-grid">
              <div class="feature-item">
                <h4>üñåÔ∏è Professional Tools</h4>
                <p>Brush (B), Eraser (E), Smart Fill (F), Magic Wand (W)</p>
              </div>
              <div class="feature-item">
                <h4>üß† AI Features</h4>
                <p>Content-aware fill, vivid colorize, crystal clear styles</p>
              </div>
              <div class="feature-item">
                <h4>üéØ Smart Selection</h4>
                <p>Visible selections with perceptual color matching</p>
              </div>
              <div class="feature-item">
                <h4>‚å®Ô∏è Shortcuts</h4>
                <p>Ctrl+Z (Undo), Ctrl+Y (Redo), B/E/F/W (Tools)</p>
              </div>
            </div>
            
            <p><strong>Pro Tip:</strong> Use the Magic Wand to select regions, then apply AI tools for professional results!</p>
            
            <button class="onboarding-close" onclick="this.parentElement.parentElement.remove(); localStorage.setItem('paintProVisited', 'true');">
              Get Started! üöÄ
            </button>
          </div>
        `;
        document.body.appendChild(modal);
      }
    }

    // --- CANVAS MANAGEMENT ---
    function fitCanvasToScreen() {
      const wrap = document.getElementById("canvas-wrap");
      const maxWidth = wrap.clientWidth - 20;
      const maxHeight = wrap.clientHeight - 20;
      
      const scaleX = maxWidth / canvas.width;
      const scaleY = maxHeight / canvas.height;
      const scale = Math.min(scaleX, scaleY, 1);
      
      canvas.style.width = (canvas.width * scale) + 'px';
      canvas.style.height = (canvas.height * scale) + 'px';
      canvasScale = scale;
      updateSelectionCanvasPosition();
    }

    function zoomCanvas(factor) {
      canvasScale *= factor;
      canvasScale = Math.max(0.1, Math.min(5, canvasScale));
      canvas.style.width = (canvas.width * canvasScale) + 'px';
      canvas.style.height = (canvas.height * canvasScale) + 'px';
      updateSelectionCanvasPosition();
    }

    function resetZoom() {
      canvasScale = 1;
      canvas.style.width = canvas.width + 'px';
      canvas.style.height = canvas.height + 'px';
      updateSelectionCanvasPosition();
    }

    // Zoom controls
    zoomInBtn.onclick = () => zoomCanvas(1.2);
    zoomOutBtn.onclick = () => zoomCanvas(0.8);
    resetZoomBtn.onclick = resetZoom;
    fitToScreenBtn.onclick = fitCanvasToScreen;

    // --- SMART TIPS ---
    const TIPS = [
      "üé® Use <b>B</b> (Brush), <b>E</b> (Eraser), <b>F</b> (Fill), <b>W</b> (Magic Wand) for quick tool switching!",
      "‚ö° Press <b>Ctrl+Z</b> to undo, <b>Ctrl+Y</b> to redo your actions.",
      "‚≠ê Magic Wand shows marching ants selection - perfect for precise editing!",
      "‚ú® AI tools now create vivid, full-of-life results!",
      "üß¨ Remove objects seamlessly with content-aware technology.",
      "üé≠ Artistic styles are now crystal clear and sharp!",
      "üéØ Refine selections work in perfect harmony.",
      "üí° Lighting effects bring dramatic life to your artwork!"
    ];

    function showTip(msg) {
      tipPop.innerHTML = msg;
      tipPop.classList.add("show-tip");
      setTimeout(() => tipPop.classList.remove("show-tip"), 5000);
    }

    tipBtn.onclick = () => showTip(TIPS[Math.floor(Math.random() * TIPS.length)]);

    // --- COLOR HARMONIES ---
    function updateHarmonies() {
      harmoniesDiv.innerHTML = "";
      let base = hexToRgb(color);
      let harmonies = [
        color,
        rgbToHex(255 - base[0], 255 - base[1], 255 - base[2]), // complement
        rgbToHex(Math.min(255, base[0] + 60), base[1], base[2]), // warm
        rgbToHex(base[0], Math.min(255, base[1] + 60), base[2]), // cool
        rgbToHex(base[0], base[1], Math.min(255, base[2] + 60)), // accent
        rgbToHex(Math.max(0, base[0] - 40), Math.max(0, base[1] - 40), Math.max(0, base[2] - 40)) // shadow
      ];
      
      harmonies.forEach((c, i) => {
        let d = document.createElement("div");
        d.style.background = c;
        d.className = (c.toLowerCase() === color.toLowerCase() ? "selected" : "");
        d.onclick = () => {
          color = c;
          colorInput.value = c;
          updateHarmonies();
          showTip("üé® Color harmony selected!");
        };
        d.title = i === 0 ? "Current" : i === 1 ? "Complement" : i === 2 ? "Warm" : i === 3 ? "Cool" : i === 4 ? "Accent" : "Shadow";
        harmoniesDiv.appendChild(d);
      });
    }

    // --- IMPROVED MAGIC WAND WITH VISIBLE SELECTION ---
    function setSelectionMask(mask) {
      selectionMask = mask;
      canvas.classList.toggle("selection-on", !!mask);
      
      if (mask) {
        renderVisibleSelection();
        showTip("‚≠ê Selection created with marching ants! Use AI tools or fill within selection.");
      } else {
        clearVisibleSelection();
      }
    }

    function renderVisibleSelection() {
      if (!selectionMask) return;
      
      // Clear selection canvas
      selectionCtx.clearRect(0, 0, selectionCanvas.width, selectionCanvas.height);
      
      // Find selection bounds for marching ants
      let minX = canvas.width, minY = canvas.height, maxX = 0, maxY = 0;
      const w = canvas.width;
      const h = canvas.height;
      
      for (let y = 0; y < h; y++) {
        for (let x = 0; x < w; x++) {
          if (selectionMask[y * w + x]) {
            minX = Math.min(minX, x);
            minY = Math.min(minY, y);
            maxX = Math.max(maxX, x);
            maxY = Math.max(maxY, y);
          }
        }
      }
      
      if (minX < maxX && minY < maxY) {
        selectionBounds = { minX, minY, maxX, maxY };
        
        // Draw marching ants border
        selectionCtx.strokeStyle = "#00ffbb";
        selectionCtx.lineWidth = 2;
        selectionCtx.setLineDash([6, 6]);
        selectionCtx.lineDashOffset = 0;
        
        // Animate marching ants
        let offset = 0;
        const animate = () => {
          if (selectionMask) {
            selectionCtx.clearRect(0, 0, selectionCanvas.width, selectionCanvas.height);
            selectionCtx.lineDashOffset = offset;
            selectionCtx.strokeRect(minX, minY, maxX - minX, maxY - minY);
            offset += 0.5;
            requestAnimationFrame(animate);
          }
        };
        animate();
        
        // Fill selection area with semi-transparent overlay
        selectionCtx.fillStyle = "rgba(0, 255, 187, 0.1)";
        selectionCtx.fillRect(minX, minY, maxX - minX, maxY - minY);
      }
    }

    function clearVisibleSelection() {
      selectionCtx.clearRect(0, 0, selectionCanvas.width, selectionCanvas.height);
      selectionBounds = null;
    }

    function magicWandPerceptual(x, y, tolerance = 25) {
      showLoading();
      setTimeout(() => {
        const img = ctx.getImageData(0, 0, canvas.width, canvas.height);
        const data = img.data;
        const w = canvas.width;
        const h = canvas.height;
        
        const startIdx = (Math.floor(y) * w + Math.floor(x)) * 4;
        const targetR = data[startIdx];
        const targetG = data[startIdx + 1];
        const targetB = data[startIdx + 2];
        const targetA = data[startIdx + 3];
        
        if (targetA < 10) {
          hideLoading();
          return;
        }
        
        const mask = new Uint8Array(w * h);
        const visited = new Uint8Array(w * h);
        const stack = [[Math.floor(x), Math.floor(y)]];
        
        while (stack.length > 0) {
          const [cx, cy] = stack.pop();
          
          if (cx < 0 || cy < 0 || cx >= w || cy >= h) continue;
          if (visited[cy * w + cx]) continue;
          
          const idx = (cy * w + cx) * 4;
          const r = data[idx];
          const g = data[idx + 1];
          const b = data[idx + 2];
          const a = data[idx + 3];
          
          if (a < 10) continue;
          
          const distance = perceptualColorDistance(targetR, targetG, targetB, r, g, b);
          
          if (distance <= tolerance) {
            visited[cy * w + cx] = 1;
            mask[cy * w + cx] = 1;
            
            stack.push([cx + 1, cy], [cx - 1, cy], [cx, cy + 1], [cx, cy - 1]);
          }
        }
        
        setSelectionMask(mask);
        hideLoading();
      }, 10);
    }

    // --- IMPROVED SMART FILL ---
    function smartFillPerceptual(x, y, fillColor, tolerance, smoothLevel = 2) {
      if (selectionMask) {
        fillWithinSelection(fillColor);
        return;
      }
      
      showLoading();
      setTimeout(() => {
        const img = ctx.getImageData(0, 0, canvas.width, canvas.height);
        const data = img.data;
        const w = canvas.width;
        const h = canvas.height;
        
        const startIdx = (Math.floor(y) * w + Math.floor(x)) * 4;
        const targetR = data[startIdx];
        const targetG = data[startIdx + 1];
        const targetB = data[startIdx + 2];
        const targetA = data[startIdx + 3];
        
        if (targetA < 10) {
          hideLoading();
          return;
        }
        
        const fillRgb = hexToRgb(fillColor);
        const visited = new Uint8Array(w * h);
        const stack = [[Math.floor(x), Math.floor(y)]];
        
        while (stack.length > 0) {
          const [cx, cy] = stack.pop();
          
          if (cx < 0 || cy < 0 || cx >= w || cy >= h) continue;
          if (visited[cy * w + cx]) continue;
          
          const idx = (cy * w + cx) * 4;
          const r = data[idx];
          const g = data[idx + 1];
          const b = data[idx + 2];
          const a = data[idx + 3];
          
          if (a < 10) continue;
          
          const distance = perceptualColorDistance(targetR, targetG, targetB, r, g, b);
          
          if (distance <= tolerance) {
            visited[cy * w + cx] = 1;
            
            if (smoothLevel > 0 && isEdgePixel(cx, cy, w, h, data, targetR, targetG, targetB, tolerance)) {
              const alpha = 0.7;
              data[idx] = Math.round(alpha * fillRgb[0] + (1 - alpha) * r);
              data[idx + 1] = Math.round(alpha * fillRgb[1] + (1 - alpha) * g);
              data[idx + 2] = Math.round(alpha * fillRgb[2] + (1 - alpha) * b);
            } else {
              data[idx] = fillRgb[0];
              data[idx + 1] = fillRgb[1];
              data[idx + 2] = fillRgb[2];
            }
            data[idx + 3] = 255;
            
            stack.push([cx + 1, cy], [cx - 1, cy], [cx, cy + 1], [cx, cy - 1]);
          }
        }
        
        ctx.putImageData(img, 0, 0);
        hideLoading();
        showTip("üé® Smart fill completed with anti-aliasing!");
      }, 10);
    }

    function isEdgePixel(x, y, w, h, data, targetR, targetG, targetB, tolerance) {
      const neighbors = [[1, 0], [-1, 0], [0, 1], [0, -1]];
      for (let [dx, dy] of neighbors) {
        const nx = x + dx;
        const ny = y + dy;
        if (nx >= 0 && ny >= 0 && nx < w && ny < h) {
          const idx = (ny * w + nx) * 4;
          const distance = perceptualColorDistance(
            targetR, targetG, targetB,
            data[idx], data[idx + 1], data[idx + 2]
          );
          if (distance > tolerance) return true;
        }
      }
      return false;
    }

    function fillWithinSelection(fillColor) {
      if (!selectionMask) return;
      
      const img = ctx.getImageData(0, 0, canvas.width, canvas.height);
      const data = img.data;
      const fillRgb = hexToRgb(fillColor);
      
      for (let i = 0; i < selectionMask.length; i++) {
        if (selectionMask[i]) {
          const idx = i * 4;
          data[idx] = fillRgb[0];
          data[idx + 1] = fillRgb[1];
          data[idx + 2] = fillRgb[2];
          data[idx + 3] = 255;
        }
      }
      
      ctx.putImageData(img, 0, 0);
      showTip("üé® Filled within selection!");
    }

    // --- PROPER UNDO/REDO SYSTEM ---
    function updateButtonStates() {
      undoBtn.disabled = undoStack.length === 0;
      redoBtn.disabled = redoStack.length === 0;
      
      undoBtn.setAttribute('data-tooltip', undoStack.length === 0 ? 'Nothing to undo' : 'Undo (Ctrl+Z)');
      redoBtn.setAttribute('data-tooltip', redoStack.length === 0 ? 'Nothing to redo' : 'Redo (Ctrl+Y)');
    }

    function pushUndo() {
      // Save current state
      const imageData = ctx.getImageData(0, 0, canvas.width, canvas.height);
      undoStack.push(imageData);
      
      if (undoStack.length > 50) undoStack.shift();
      redoStack.length = 0;
      updateButtonStates();
    }

    function popUndo() {
      if (undoStack.length === 0) return;
      
      // Save current state to redo
      const currentState = ctx.getImageData(0, 0, canvas.width, canvas.height);
      redoStack.push(currentState);
      
      // Restore previous state
      const previousState = undoStack.pop();
      ctx.putImageData(previousState, 0, 0);
      
      // Clear any selection
      setSelectionMask(null);
      updateButtonStates();
    }

    function popRedo() {
      if (redoStack.length === 0) return;
      
      // Save current state to undo
      const currentState = ctx.getImageData(0, 0, canvas.width, canvas.height);
      undoStack.push(currentState);
      
      // Restore redo state
      const redoState = redoStack.pop();
      ctx.putImageData(redoState, 0, 0);
      
      updateButtonStates();
    }

    // --- AI TOOLS ---
    document.getElementById("ai-edge").onclick = function() {
      showLoading();
      setTimeout(() => {
        if (selectionMask) {
          edgeDetectInSelection();
        } else {
          edgeDetectFullImage();
        }
        hideLoading();
        showTip("üéØ Edge detection completed!");
      }, 10);
    };

    function edgeDetectInSelection() {
      const img = ctx.getImageData(0, 0, canvas.width, canvas.height);
      const data = img.data;
      const w = canvas.width;
      const h = canvas.height;
      const output = new Uint8ClampedArray(data.length);
      
      // Copy original data
      for (let i = 0; i < data.length; i++) {
        output[i] = data[i];
      }
      
      const sobelX = [[-1, 0, 1], [-2, 0, 2], [-1, 0, 1]];
      const sobelY = [[-1, -2, -1], [0, 0, 0], [1, 2, 1]];
      
      for (let y = 1; y < h - 1; y++) {
        for (let x = 1; x < w - 1; x++) {
          if (selectionMask[y * w + x]) {
            let gx = 0, gy = 0;
            
            for (let ky = -1; ky <= 1; ky++) {
              for (let kx = -1; kx <= 1; kx++) {
                const idx = ((y + ky) * w + (x + kx)) * 4;
                const gray = (data[idx] + data[idx + 1] + data[idx + 2]) / 3;
                gx += gray * sobelX[ky + 1][kx + 1];
                gy += gray * sobelY[ky + 1][kx + 1];
              }
            }
            
            const magnitude = Math.min(255, Math.sqrt(gx * gx + gy * gy));
            const edge = 255 - magnitude;
            const idx = (y * w + x) * 4;
            
            output[idx] = output[idx + 1] = output[idx + 2] = edge;
            output[idx + 3] = 255;
          }
        }
      }
      
      ctx.putImageData(new ImageData(output, w, h), 0, 0);
    }

    function edgeDetectFullImage() {
      const img = ctx.getImageData(0, 0, canvas.width, canvas.height);
      const data = img.data;
      const w = canvas.width;
      const h = canvas.height;
      const output = new Uint8ClampedArray(data.length);
      
      const sobelX = [[-1, 0, 1], [-2, 0, 2], [-1, 0, 1]];
      const sobelY = [[-1, -2, -1], [0, 0, 0], [1, 2, 1]];
      
      for (let y = 1; y < h - 1; y++) {
        for (let x = 1; x < w - 1; x++) {
          let gx = 0, gy = 0;
          
          for (let ky = -1; ky <= 1; ky++) {
            for (let kx = -1; kx <= 1; kx++) {
              const idx = ((y + ky) * w + (x + kx)) * 4;
              const gray = (data[idx] + data[idx + 1] + data[idx + 2]) / 3;
              gx += gray * sobelX[ky + 1][kx + 1];
              gy += gray * sobelY[ky + 1][kx + 1];
            }
          }
          
          const magnitude = Math.min(255, Math.sqrt(gx * gx + gy * gy));
          const edge = 255 - magnitude;
          const idx = (y * w + x) * 4;
          
          output[idx] = output[idx + 1] = output[idx + 2] = edge;
          output[idx + 3] = 255;
        }
      }
      
      ctx.putImageData(new ImageData(output, w, h), 0, 0);
    }

    // Content-aware removal
    document.getElementById("ai-inpaint").onclick = function() {
      if (!selectionMask) {
        showTip("‚ö†Ô∏è Please select a region with Magic Wand first!");
        return;
      }
      
      pushUndo();
      showLoading();
      setTimeout(() => {
        contentAwareRemove();
        setSelectionMask(null);
        hideLoading();
        showTip("üß¨ Object removed seamlessly!");
      }, 10);
    };

    function contentAwareRemove() {
      const img = ctx.getImageData(0, 0, canvas.width, canvas.height);
      const data = img.data;
      const w = canvas.width;
      const h = canvas.height;
      
      // Multi-pass content-aware fill with improved algorithm
      for (let pass = 0; pass < 5; pass++) {
        for (let y = 1; y < h - 1; y++) {
          for (let x = 1; x < w - 1; x++) {
            if (selectionMask[y * w + x]) {
              let r = 0, g = 0, b = 0, totalWeight = 0;
              
              // Sample from surrounding non-selected pixels with distance weighting
              for (let dy = -3; dy <= 3; dy++) {
                for (let dx = -3; dx <= 3; dx++) {
                  const nx = x + dx;
                  const ny = y + dy;
                  if (nx >= 0 && ny >= 0 && nx < w && ny < h && !selectionMask[ny * w + nx]) {
                    const idx = (ny * w + nx) * 4;
                    const distance = Math.sqrt(dx * dx + dy * dy);
                    const weight = 1 / (distance + 0.1);
                    
                    r += data[idx] * weight;
                    g += data[idx + 1] * weight;
                    b += data[idx + 2] * weight;
                    totalWeight += weight;
                  }
                }
              }
              
              if (totalWeight > 0) {
                const idx = (y * w + x) * 4;
                data[idx] = Math.round(r / totalWeight);
                data[idx + 1] = Math.round(g / totalWeight);
                data[idx + 2] = Math.round(b / totalWeight);
                data[idx + 3] = 255;
              }
            }
          }
        }
      }
      
      ctx.putImageData(img, 0, 0);
    }

    // Patch Tool - Working Implementation
    document.getElementById("ai-patch").onclick = function() {
      if (!selectionMask) {
        showTip("‚ö†Ô∏è Please select a region with Magic Wand first!");
        return;
      }
      
      pushUndo();
      showLoading();
      setTimeout(() => {
        patchTool();
        setSelectionMask(null);
        hideLoading();
        showTip("üîß Patch tool applied successfully!");
      }, 10);
    };

    function patchTool() {
      const img = ctx.getImageData(0, 0, canvas.width, canvas.height);
      const data = img.data;
      const w = canvas.width;
      const h = canvas.height;
      
      // Find the best matching area to use as patch source
      const { minX, minY, maxX, maxY } = getSelectionBounds();
      const selectionWidth = maxX - minX;
      const selectionHeight = maxY - minY;
      
      let bestMatch = null;
      let bestScore = Infinity;
      
      // Search for best matching region
      for (let sy = 0; sy <= h - selectionHeight; sy += 5) {
        for (let sx = 0; sx <= w - selectionWidth; sx += 5) {
          // Skip if overlaps with selection
          if (sx < maxX && sx + selectionWidth > minX && 
              sy < maxY && sy + selectionHeight > minY) continue;
          
          let score = 0;
          let samples = 0;
          
          // Sample edge pixels for matching
          for (let y = 0; y < selectionHeight; y += 2) {
            for (let x = 0; x < selectionWidth; x += 2) {
              if (selectionMask[(minY + y) * w + (minX + x)]) {
                // Check surrounding pixels for context matching
                for (let dy = -1; dy <= 1; dy++) {
                  for (let dx = -1; dx <= 1; dx++) {
                    const selIdx = ((minY + y + dy) * w + (minX + x + dx)) * 4;
                    const srcIdx = ((sy + y + dy) * w + (sx + x + dx)) * 4;
                    
                    if (!selectionMask[(minY + y + dy) * w + (minX + x + dx)]) {
                      const diff = Math.abs(data[selIdx] - data[srcIdx]) +
                                   Math.abs(data[selIdx + 1] - data[srcIdx + 1]) +
                                   Math.abs(data[selIdx + 2] - data[srcIdx + 2]);
                      score += diff;
                      samples++;
                    }
                  }
                }
              }
            }
          }
          
          if (samples > 0) {
            score /= samples;
            if (score < bestScore) {
              bestScore = score;
              bestMatch = { sx, sy };
            }
          }
        }
      }
      
      // Apply the best patch
      if (bestMatch) {
        for (let y = 0; y < selectionHeight; y++) {
          for (let x = 0; x < selectionWidth; x++) {
                        if (selectionMask[(minY + y) * w + (minX + x)]) {
              const srcIdx = ((bestMatch.sy + y) * w + (bestMatch.sx + x)) * 4;
              const dstIdx = ((minY + y) * w + (minX + x)) * 4;
              
              data[dstIdx] = data[srcIdx];
              data[dstIdx + 1] = data[srcIdx + 1];
              data[dstIdx + 2] = data[srcIdx + 2];
              data[dstIdx + 3] = 255;
            }
          }
        }
      }
      
      ctx.putImageData(img, 0, 0);
    }

    function getSelectionBounds() {
      let minX = canvas.width, minY = canvas.height, maxX = 0, maxY = 0;
      const w = canvas.width;
      const h = canvas.height;
      
      for (let y = 0; y < h; y++) {
        for (let x = 0; x < w; x++) {
          if (selectionMask[y * w + x]) {
            minX = Math.min(minX, x);
            minY = Math.min(minY, y);
            maxX = Math.max(maxX, x);
            maxY = Math.max(maxY, y);
          }
        }
      }
      
      return { minX, minY, maxX, maxY };
    }

    // Refine Selection - Working in Harmony
    let refineSlider = document.getElementById("ai-refine");
    refineSlider.oninput = () => document.getElementById("ai-refine-val").textContent = refineSlider.value;

    document.getElementById("ai-refine-btn").onclick = function() {
      if (!selectionMask) {
        showTip("‚ö†Ô∏è Please select a region first!");
        return;
      }
      
      const refinement = +refineSlider.value;
      refineSelection(refinement);
      showTip("üéØ Selection refined in perfect harmony!");
    };

    function refineSelection(refinement) {
      const w = canvas.width;
      const h = canvas.height;
      const newMask = new Uint8Array(w * h);
      
      if (refinement > 0) {
        // Expand selection
        for (let y = 0; y < h; y++) {
          for (let x = 0; x < w; x++) {
            let shouldSelect = selectionMask[y * w + x];
            
            if (!shouldSelect) {
              // Check if within expansion radius of selected pixel
              for (let dy = -refinement; dy <= refinement && !shouldSelect; dy++) {
                for (let dx = -refinement; dx <= refinement && !shouldSelect; dx++) {
                  const nx = x + dx;
                  const ny = y + dy;
                  if (nx >= 0 && ny >= 0 && nx < w && ny < h) {
                    const distance = Math.sqrt(dx * dx + dy * dy);
                    if (distance <= refinement && selectionMask[ny * w + nx]) {
                      shouldSelect = true;
                    }
                  }
                }
              }
            }
            
            newMask[y * w + x] = shouldSelect ? 1 : 0;
          }
        }
      } else {
        // Contract selection
        const contractAmount = Math.abs(refinement);
        for (let y = 0; y < h; y++) {
          for (let x = 0; x < w; x++) {
            if (selectionMask[y * w + x]) {
              let shouldKeep = true;
              
              // Check if all pixels within contract radius are selected
              for (let dy = -contractAmount; dy <= contractAmount && shouldKeep; dy++) {
                for (let dx = -contractAmount; dx <= contractAmount && shouldKeep; dx++) {
                  const nx = x + dx;
                  const ny = y + dy;
                  const distance = Math.sqrt(dx * dx + dy * dy);
                  
                  if (distance <= contractAmount) {
                    if (nx < 0 || ny < 0 || nx >= w || ny >= h || !selectionMask[ny * w + nx]) {
                      shouldKeep = false;
                    }
                  }
                }
              }
              
              newMask[y * w + x] = shouldKeep ? 1 : 0;
            }
          }
        }
      }
      
      setSelectionMask(newMask);
    }

    // Vivid Color Enhancement
    document.getElementById("ai-colorize").onclick = function() {
      pushUndo();
      showLoading();
      setTimeout(() => {
        if (selectionMask) {
          vividColorsInSelection();
        } else {
          vividColorsFullImage();
        }
        hideLoading();
        showTip("üé® Vivid colors applied - full of life!");
      }, 10);
    };

    function vividColorsInSelection() {
      const img = ctx.getImageData(0, 0, canvas.width, canvas.height);
      const data = img.data;
      const w = canvas.width;
      
      for (let i = 0; i < selectionMask.length; i++) {
        if (selectionMask[i]) {
          const idx = i * 4;
          enhancePixelVividness(data, idx);
        }
      }
      
      ctx.putImageData(img, 0, 0);
    }

    function vividColorsFullImage() {
      const img = ctx.getImageData(0, 0, canvas.width, canvas.height);
      const data = img.data;
      
      for (let i = 0; i < data.length; i += 4) {
        enhancePixelVividness(data, i);
      }
      
      ctx.putImageData(img, 0, 0);
    }

    function enhancePixelVividness(data, idx) {
      const r = data[idx];
      const g = data[idx + 1];
      const b = data[idx + 2];
      
      // Convert to HSV for better saturation control
      const hsv = rgbToHsv(r, g, b);
      
      // Boost saturation dramatically
      hsv[1] = Math.min(1, hsv[1] * 1.8 + 0.2);
      
      // Enhance brightness selectively
      if (hsv[2] < 0.3) {
        hsv[2] = Math.min(1, hsv[2] * 1.4); // Brighten shadows
      } else if (hsv[2] > 0.7) {
        hsv[2] = Math.min(1, hsv[2] * 1.1); // Slightly brighten highlights
      } else {
        hsv[2] = Math.min(1, hsv[2] * 1.3); // Boost midtones significantly
      }
      
      // Convert back to RGB
      const newRgb = hsvToRgb(hsv[0], hsv[1], hsv[2]);
      data[idx] = newRgb[0];
      data[idx + 1] = newRgb[1];
      data[idx + 2] = newRgb[2];
    }

    function rgbToHsv(r, g, b) {
      r /= 255;
      g /= 255;
      b /= 255;
      
      const max = Math.max(r, g, b);
      const min = Math.min(r, g, b);
      const diff = max - min;
      
      let h = 0;
      if (diff !== 0) {
        if (max === r) h = ((g - b) / diff) % 6;
        else if (max === g) h = (b - r) / diff + 2;
        else h = (r - g) / diff + 4;
      }
      h = Math.round(h * 60);
      if (h < 0) h += 360;
      
      const s = max === 0 ? 0 : diff / max;
      const v = max;
      
      return [h / 360, s, v];
    }

    function hsvToRgb(h, s, v) {
      h *= 360;
      const c = v * s;
      const x = c * (1 - Math.abs((h / 60) % 2 - 1));
      const m = v - c;
      
      let r = 0, g = 0, b = 0;
      
      if (0 <= h && h < 60) [r, g, b] = [c, x, 0];
      else if (60 <= h && h < 120) [r, g, b] = [x, c, 0];
      else if (120 <= h && h < 180) [r, g, b] = [0, c, x];
      else if (180 <= h && h < 240) [r, g, b] = [0, x, c];
      else if (240 <= h && h < 300) [r, g, b] = [x, 0, c];
      else if (300 <= h && h < 360) [r, g, b] = [c, 0, x];
      
      return [
        Math.round((r + m) * 255),
        Math.round((g + m) * 255),
        Math.round((b + m) * 255)
      ];
    }

    // Color Harmony Enhancement
    document.getElementById("ai-color-match").onclick = function() {
      pushUndo();
      showLoading();
      setTimeout(() => {
        if (selectionMask) {
          colorHarmonyInSelection();
        } else {
          colorHarmonyFullImage();
        }
        hideLoading();
        showTip("üåà Color harmony enhanced - perfect balance!");
      }, 10);
    };

    function colorHarmonyInSelection() {
      const img = ctx.getImageData(0, 0, canvas.width, canvas.height);
      const data = img.data;
      
      for (let i = 0; i < selectionMask.length; i++) {
        if (selectionMask[i]) {
          const idx = i * 4;
          harmonizePixelColor(data, idx);
        }
      }
      
      ctx.putImageData(img, 0, 0);
    }

    function colorHarmonyFullImage() {
      const img = ctx.getImageData(0, 0, canvas.width, canvas.height);
      const data = img.data;
      
      for (let i = 0; i < data.length; i += 4) {
        harmonizePixelColor(data, i);
      }
      
      ctx.putImageData(img, 0, 0);
    }

    function harmonizePixelColor(data, idx) {
      const r = data[idx];
      const g = data[idx + 1];
      const b = data[idx + 2];
      
      // Apply warm/cool balance based on color temperature
      const temperature = (r - b) / 255;
      
      if (temperature > 0.1) {
        // Warm tones - enhance warmth
        data[idx] = Math.min(255, r * 1.15);
        data[idx + 1] = Math.min(255, g * 1.08);
        data[idx + 2] = Math.min(255, b * 0.95);
      } else if (temperature < -0.1) {
        // Cool tones - enhance coolness
        data[idx] = Math.min(255, r * 0.95);
        data[idx + 1] = Math.min(255, g * 1.05);
        data[idx + 2] = Math.min(255, b * 1.15);
      } else {
        // Neutral - slight enhancement
        data[idx] = Math.min(255, r * 1.05);
        data[idx + 1] = Math.min(255, g * 1.05);
        data[idx + 2] = Math.min(255, b * 1.05);
      }
    }

    // Saturation Boost
    document.getElementById("ai-saturation").onclick = function() {
      pushUndo();
      showLoading();
      setTimeout(() => {
        if (selectionMask) {
          boostSaturationInSelection();
        } else {
          boostSaturationFullImage();
        }
        hideLoading();
        showTip("üí´ Saturation boosted - vibrant and alive!");
      }, 10);
    };

    function boostSaturationInSelection() {
      const img = ctx.getImageData(0, 0, canvas.width, canvas.height);
      const data = img.data;
      
      for (let i = 0; i < selectionMask.length; i++) {
        if (selectionMask[i]) {
          const idx = i * 4;
          boostPixelSaturation(data, idx);
        }
      }
      
      ctx.putImageData(img, 0, 0);
    }

    function boostSaturationFullImage() {
      const img = ctx.getImageData(0, 0, canvas.width, canvas.height);
      const data = img.data;
      
      for (let i = 0; i < data.length; i += 4) {
        boostPixelSaturation(data, i);
      }
      
      ctx.putImageData(img, 0, 0);
    }

    function boostPixelSaturation(data, idx) {
      const r = data[idx] / 255;
      const g = data[idx + 1] / 255;
      const b = data[idx + 2] / 255;
      
      const max = Math.max(r, g, b);
      const min = Math.min(r, g, b);
      const delta = max - min;
      
      if (delta > 0) {
        const saturation = delta / max;
        const newSaturation = Math.min(1, saturation * 2.2);
        
        const factor = newSaturation / saturation;
        const gray = (r + g + b) / 3;
        
        data[idx] = Math.round(Math.min(255, (gray + (r - gray) * factor) * 255));
        data[idx + 1] = Math.round(Math.min(255, (gray + (g - gray) * factor) * 255));
        data[idx + 2] = Math.round(Math.min(255, (gray + (b - gray) * factor) * 255));
      }
    }

    // Dramatic Lighting Effects
    document.getElementById("ai-dodge").onclick = () => { 
      setToolUI("dodge"); 
      showTip("üí° Dodge tool activated - paint to create vivid highlights!"); 
    };
    
    document.getElementById("ai-burn").onclick = () => { 
      setToolUI("burn"); 
      showTip("üî• Burn tool activated - paint to create dramatic shadows!"); 
    };

    document.getElementById("ai-dramatic").onclick = function() {
      pushUndo();
      showLoading();
      setTimeout(() => {
        if (selectionMask) {
          dramaticLightInSelection();
        } else {
          dramaticLightFullImage();
        }
        hideLoading();
        showTip("‚ö° Dramatic lighting applied - full of life and energy!");
      }, 10);
    };

    function dramaticLightInSelection() {
      const img = ctx.getImageData(0, 0, canvas.width, canvas.height);
      const data = img.data;
      
      for (let i = 0; i < selectionMask.length; i++) {
        if (selectionMask[i]) {
          const idx = i * 4;
          applyDramaticLighting(data, idx);
        }
      }
      
      ctx.putImageData(img, 0, 0);
    }

    function dramaticLightFullImage() {
      const img = ctx.getImageData(0, 0, canvas.width, canvas.height);
      const data = img.data;
      
      for (let i = 0; i < data.length; i += 4) {
        applyDramaticLighting(data, i);
      }
      
      ctx.putImageData(img, 0, 0);
    }

    function applyDramaticLighting(data, idx) {
      const r = data[idx];
      const g = data[idx + 1];
      const b = data[idx + 2];
      const luminance = 0.299 * r + 0.587 * g + 0.114 * b;
      
      let factor;
      if (luminance < 85) {
        // Deep shadows - make darker but preserve some detail
        factor = 0.6;
      } else if (luminance > 170) {
        // Bright highlights - make brighter and more vivid
        factor = 1.4;
      } else {
        // Midtones - enhance contrast
        factor = luminance < 128 ? 0.8 : 1.2;
      }
      
      data[idx] = Math.min(255, Math.max(0, r * factor));
      data[idx + 1] = Math.min(255, Math.max(0, g * factor));
      data[idx + 2] = Math.min(255, Math.max(0, b * factor));
    }

    // Crystal Clear Artistic Styles
    document.getElementById("ai-style-sketch").onclick = function() {
      pushUndo();
      showLoading();
      setTimeout(() => {
        if (selectionMask) {
          sharpSketchInSelection();
        } else {
          sharpSketchFullImage();
        }
        hideLoading();
        showTip("‚úèÔ∏è Sharp pencil sketch applied - crystal clear details!");
      }, 50);
    };

    function sharpSketchInSelection() {
      const img = ctx.getImageData(0, 0, canvas.width, canvas.height);
      const data = img.data;
      const w = canvas.width;
      
      // Create edge-enhanced grayscale in selection
      for (let i = 0; i < selectionMask.length; i++) {
        if (selectionMask[i]) {
          const idx = i * 4;
          const gray = data[idx] * 0.299 + data[idx + 1] * 0.587 + data[idx + 2] * 0.114;
          
          // Enhanced contrast for sharper lines
          const enhanced = gray < 128 ? gray * 0.7 : Math.min(255, gray * 1.3);
          
          data[idx] = data[idx + 1] = data[idx + 2] = enhanced;
        }
      }
      
      // Apply sharpening to selected area
      sharpenInSelection(data, w);
      ctx.putImageData(img, 0, 0);
    }

    function sharpSketchFullImage() {
      const img = ctx.getImageData(0, 0, canvas.width, canvas.height);
      const data = img.data;
      const w = canvas.width;
      const h = canvas.height;
      
      // Convert to high-contrast grayscale
      for (let i = 0; i < data.length; i += 4) {
        const gray = data[i] * 0.299 + data[i + 1] * 0.587 + data[i + 2] * 0.114;
        const enhanced = gray < 128 ? gray * 0.7 : Math.min(255, gray * 1.3);
        data[i] = data[i + 1] = data[i + 2] = enhanced;
      }
      
      // Apply edge enhancement
      const edgeData = new Uint8ClampedArray(data.length);
      const kernel = [
        [-1, -1, -1],
        [-1,  9, -1],
        [-1, -1, -1]
      ];
      
      for (let y = 1; y < h - 1; y++) {
        for (let x = 1; x < w - 1; x++) {
          let sum = 0;
          for (let ky = -1; ky <= 1; ky++) {
            for (let kx = -1; kx <= 1; kx++) {
              const idx = ((y + ky) * w + (x + kx)) * 4;
              sum += data[idx] * kernel[ky + 1][kx + 1];
            }
          }
          const idx = (y * w + x) * 4;
          const sharpened = Math.min(255, Math.max(0, sum));
          edgeData[idx] = edgeData[idx + 1] = edgeData[idx + 2] = sharpened;
          edgeData[idx + 3] = 255;
        }
      }
      
      ctx.putImageData(new ImageData(edgeData, w, h), 0, 0);
    }

    function sharpenInSelection(data, width) {
      const kernel = [
        [0, -1, 0],
        [-1, 5, -1],
        [0, -1, 0]
      ];
      
      const original = new Uint8ClampedArray(data);
      
      for (let i = 0; i < selectionMask.length; i++) {
        if (selectionMask[i]) {
          const y = Math.floor(i / width);
          const x = i % width;
          
          if (y > 0 && y < canvas.height - 1 && x > 0 && x < width - 1) {
            let sum = 0;
            for (let ky = -1; ky <= 1; ky++) {
              for (let kx = -1; kx <= 1; kx++) {
                const idx = ((y + ky) * width + (x + kx)) * 4;
                sum += original[idx] * kernel[ky + 1][kx + 1];
              }
            }
            const idx = i * 4;
            const sharpened = Math.min(255, Math.max(0, sum));
            data[idx] = data[idx + 1] = data[idx + 2] = sharpened;
          }
        }
      }
    }

    // Vivid Paint Style
    document.getElementById("ai-style-paint").onclick = function() {
      pushUndo();
      showLoading();
      setTimeout(() => {
        if (selectionMask) {
          vividPaintInSelection();
        } else {
          vividPaintFullImage();
        }
        hideLoading();
        showTip("üé® Vivid paint style applied - bursting with life!");
      }, 50);
    };

    function vividPaintInSelection() {
      const img = ctx.getImageData(0, 0, canvas.width, canvas.height);
      const data = img.data;
      
      for (let i = 0; i < selectionMask.length; i++) {
        if (selectionMask[i]) {
          const idx = i * 4;
          applyVividPaintEffect(data, idx);
        }
      }
      
      ctx.putImageData(img, 0, 0);
    }

    function vividPaintFullImage() {
      const img = ctx.getImageData(0, 0, canvas.width, canvas.height);
      const data = img.data;
      
      for (let i = 0; i < data.length; i += 4) {
        applyVividPaintEffect(data, i);
      }
      
      ctx.putImageData(img, 0, 0);
    }

    function applyVividPaintEffect(data, idx) {
      // Quantize colors for paint-like effect
      const levels = 16;
      let r = Math.round(data[idx] / levels) * levels;
      let g = Math.round(data[idx + 1] / levels) * levels;
      let b = Math.round(data[idx + 2] / levels) * levels;
      
      // Boost saturation dramatically
      const hsv = rgbToHsv(r, g, b);
      hsv[1] = Math.min(1, hsv[1] * 2.5); // Extreme saturation boost
      hsv[2] = Math.min(1, hsv[2] * 1.2); // Slight brightness boost
      
      const newRgb = hsvToRgb(hsv[0], hsv[1], hsv[2]);
      data[idx] = newRgb[0];
      data[idx + 1] = newRgb[1];
      data[idx + 2] = newRgb[2];
    }

    // Crystal Clear Effect
    document.getElementById("ai-style-watercolor").onclick = function() {
      pushUndo();
      showLoading();
      setTimeout(() => {
        if (selectionMask) {
          crystalClearInSelection();
        } else {
          crystalClearFullImage();
        }
        hideLoading();
        showTip("üíé Crystal clear effect applied - ultra sharp and vivid!");
      }, 50);
    };

    function crystalClearInSelection() {
      const img = ctx.getImageData(0, 0, canvas.width, canvas.height);
      const data = img.data;
      const w = canvas.width;
      
      // Apply unsharp mask for crystal clarity
      applyCrystalClarityToSelection(data, w);
      ctx.putImageData(img, 0, 0);
    }

    function crystalClearFullImage() {
      const img = ctx.getImageData(0, 0, canvas.width, canvas.height);
      const data = img.data;
      const w = canvas.width;
      const h = canvas.height;
      
      // Create unsharp mask for ultimate clarity
      const blurred = new Uint8ClampedArray(data);
      
      // Apply Gaussian blur
      for (let y = 1; y < h - 1; y++) {
        for (let x = 1; x < w - 1; x++) {
          for (let c = 0; c < 3; c++) {
            let sum = 0;
            for (let dy = -1; dy <= 1; dy++) {
              for (let dx = -1; dx <= 1; dx++) {
                const idx = ((y + dy) * w + (x + dx)) * 4 + c;
                sum += data[idx];
              }
            }
            blurred[(y * w + x) * 4 + c] = sum / 9;
          }
        }
      }
      
      // Apply unsharp mask
      for (let i = 0; i < data.length; i += 4) {
        for (let c = 0; c < 3; c++) {
          const original = data[i + c];
          const blur = blurred[i + c];
          const enhanced = original + (original - blur) * 2; // Strong enhancement
          data[i + c] = Math.min(255, Math.max(0, enhanced));
        }
      }
      
      ctx.putImageData(img, 0, 0);
    }

    function applyCrystalClarityToSelection(data, width) {
      const original = new Uint8ClampedArray(data);
      
      // Apply unsharp mask to selected pixels only
      for (let i = 0; i < selectionMask.length; i++) {
        if (selectionMask[i]) {
          const y = Math.floor(i / width);
          const x = i % width;
          
          if (y > 0 && y < canvas.height - 1 && x > 0 && x < width - 1) {
            for (let c = 0; c < 3; c++) {
              let blur = 0;
              for (let dy = -1; dy <= 1; dy++) {
                for (let dx = -1; dx <= 1; dx++) {
                  const idx = ((y + dy) * width + (x + dx)) * 4 + c;
                  blur += original[idx];
                }
              }
              blur /= 9;
              
              const idx = i * 4 + c;
              const enhanced = original[idx] + (original[idx] - blur) * 2.5;
              data[idx] = Math.min(255, Math.max(0, enhanced));
            }
          }
        }
      }
    }

    // Selective Blur - Only in Selected Areas
    document.getElementById("ai-blur").onclick = function() {
      if (!selectionMask) {
        showTip("‚ö†Ô∏è Please select an area first to apply selective blur!");
        return;
      }
      
      pushUndo();
      showLoading();
      setTimeout(() => {
        selectiveBlur();
        hideLoading();
        showTip("üå´Ô∏è Selective blur applied to selected area only!");
      }, 10);
    };

    function selectiveBlur() {
      const img = ctx.getImageData(0, 0, canvas.width, canvas.height);
      const data = img.data;
      const w = canvas.width;
      const h = canvas.height;
      const original = new Uint8ClampedArray(data);
      
      // Apply Gaussian blur only to selected pixels
      for (let i = 0; i < selectionMask.length; i++) {
        if (selectionMask[i]) {
          const y = Math.floor(i / w);
          const x = i % w;
          
          if (y > 1 && y < h - 2 && x > 1 && x < w - 2) {
            for (let c = 0; c < 3; c++) {
              let sum = 0;
              let weight = 0;
              
              // 5x5 Gaussian kernel
              for (let dy = -2; dy <= 2; dy++) {
                for (let dx = -2; dx <= 2; dx++) {
                  const idx = ((y + dy) * w + (x + dx)) * 4 + c;
                  const distance = Math.sqrt(dx * dx + dy * dy);
                  const gaussian = Math.exp(-(distance * distance) / 2);
                  sum += original[idx] * gaussian;
                  weight += gaussian;
                }
              }
              
              data[i * 4 + c] = sum / weight;
            }
          }
        }
      }
      
      ctx.putImageData(img, 0, 0);
    }

    // Smart Fill Controls
    let smoothSlider = document.getElementById("ai-smooth");
    smoothSlider.oninput = () => document.getElementById("ai-smooth-val").textContent = smoothSlider.value;

    document.getElementById("ai-smooth-btn").onclick = function() {
      const smoothLevel = +smoothSlider.value;
      fillTolerance = 20 + smoothLevel * 5;
      showTip(`üåà Anti-aliasing level set to ${smoothLevel}`);
    };

    // Auto Contrast
    document.getElementById("ai-contrast").onclick = function() {
      pushUndo();
      showLoading();
      setTimeout(() => {
        if (selectionMask) {
          autoContrastInSelection();
        } else {
          autoContrastFullImage();
        }
        hideLoading();
        showTip("üìà Auto contrast applied!");
      }, 10);
    };

    function autoContrastInSelection() {
      const img = ctx.getImageData(0, 0, canvas.width, canvas.height);
      const data = img.data;
      
      // Find min/max values in selection
      let min = 255, max = 0;
      for (let i = 0; i < selectionMask.length; i++) {
        if (selectionMask[i]) {
          const idx = i * 4;
          const avg = (data[idx] + data[idx + 1] + data[idx + 2]) / 3;
          min = Math.min(min, avg);
          max = Math.max(max, avg);
        }
      }
      
      const range = max - min;
      const scale = range > 0 ? 255 / range : 1;
      
      for (let i = 0; i < selectionMask.length; i++) {
        if (selectionMask[i]) {
          const idx = i * 4;
          for (let j = 0; j < 3; j++) {
            data[idx + j] = Math.min(255, Math.max(0, (data[idx + j] - min) * scale));
          }
        }
      }
      
      ctx.putImageData(img, 0, 0);
    }

    function autoContrastFullImage() {
      const img = ctx.getImageData(0, 0, canvas.width, canvas.height);
      const data = img.data;
      
      let min = 255, max = 0;
      for (let i = 0; i < data.length; i += 4) {
        const avg = (data[i] + data[i + 1] + data[i + 2]) / 3;
        min = Math.min(min, avg);
        max = Math.max(max, avg);
      }
      
      const range = max - min;
      const scale = range > 0 ? 255 / range : 1;
      
      for (let i = 0; i < data.length; i += 4) {
        for (let j = 0; j < 3; j++) {
          data[i + j] = Math.min(255, Math.max(0, (data[i + j] - min) * scale));
        }
      }
      
      ctx.putImageData(img, 0, 0);
    }

    // Sharpen
    document.getElementById("ai-sharpen").onclick = function() {
      pushUndo();
      showLoading();
      setTimeout(() => {
        if (selectionMask) {
          sharpenInSelectionArea();
        } else {
          sharpenFullImage();
        }
        hideLoading();
        showTip("üîç Image sharpened!");
      }, 10);
    };

    function sharpenInSelectionArea() {
      const img = ctx.getImageData(0, 0, canvas.width, canvas.height);
      const data = img.data;
      const w = canvas.width;
      
      sharpenInSelection(data, w);
      ctx.putImageData(img, 0, 0);
    }

    function sharpenFullImage() {
      const img = ctx.getImageData(0, 0, canvas.width, canvas.height);
      const data = img.data;
      const w = canvas.width;
      const h = canvas.height;
      const output = new Uint8ClampedArray(data.length);
      
      const kernel = [
        [0, -1, 0],
        [-1, 5, -1],
        [0, -1, 0]
      ];
      
      for (let y = 1; y < h - 1; y++) {
        for (let x = 1; x < w - 1; x++) {
          for (let c = 0; c < 3; c++) {
            let sum = 0;
            for (let ky = -1; ky <= 1; ky++) {
              for (let kx = -1; kx <= 1; kx++) {
                const idx = ((y + ky) * w + (x + kx)) * 4 + c;
                sum += data[idx] * kernel[ky + 1][kx + 1];
              }
            }
            const idx = (y * w + x) * 4 + c;
            output[idx] = Math.min(255, Math.max(0, sum));
          }
          output[(y * w + x) * 4 + 3] = 255;
        }
      }
      
      ctx.putImageData(new ImageData(output, w, h), 0, 0);
    }

    // --- DRAWING TOOLS ---
    function setToolUI(t) {
      tool = t;
      [toolBrush, toolEraser, toolFill, magicWandBtn].forEach(btn => btn.classList.remove("active"));
      
      if (tool === "brush") toolBrush.classList.add("active");
      else if (tool === "eraser") toolEraser.classList.add("active");
      else if (tool === "fill") toolFill.classList.add("active");
      else if (tool === "magicWand") magicWandBtn.classList.add("active");
      
      if (tool === "brush" || tool === "eraser") {
        if (selectionMask) {
          setSelectionMask(null);
          showTip("üé® Selection cleared - ready to paint!");
        }
      }
      
      const cursors = {
        "brush": "crosshair",
        "eraser": "not-allowed",
        "fill": "cell",
        "magicWand": "crosshair",
        "dodge": "crosshair",
        "burn": "crosshair"
      };
      
      canvas.style.cursor = cursors[tool] || "crosshair";
      updateButtonStates();
    }

    colorInput.value = color;
    colorInput.oninput = e => { 
      color = e.target.value; 
      updateHarmonies();
      showTip("üé® Color selected!");
    };
    
    sizeInput.oninput = e => { 
      size = +e.target.value; 
      sizeVal.textContent = size + 'px';
    };

    function xy(e) {
      const rect = canvas.getBoundingClientRect();
      if (e.touches) e = e.touches[0];
      return [
        (e.clientX - rect.left) * canvas.width / rect.width,
        (e.clientY - rect.top) * canvas.height / rect.height
      ];
    }

    // --- DRAWING ENGINE ---
    canvas.onmousedown = e => {
      const [x, y] = xy(e);
      
      if (tool === "fill") {
        pushUndo();
        smartFillPerceptual(x, y, color, fillTolerance, +smoothSlider.value);
        return;
      }
      
      if (tool === "magicWand") {
        magicWandPerceptual(x, y, fillTolerance);
        return;
      }
      
      if (["eraser", "brush", "dodge", "burn"].includes(tool)) {
        drawing = true;
        last = [x, y];
        ctx.beginPath();
        ctx.moveTo(x, y);
        ctx.lineWidth = size;
        ctx.lineCap = ctx.lineJoin = "round";
        
        if (tool === "eraser") {
          ctx.globalCompositeOperation = "destination-out";
          ctx.strokeStyle = "rgba(0,0,0,1)";
        } else {
          ctx.globalCompositeOperation = "source-over";
          ctx.strokeStyle = color;
        }
        
        ctx.globalAlpha = tool === "brush" ? 0.97 : 1;
        pushUndo();
      }
    };

    canvas.onmousemove = e => {
      if (!drawing) return;
      
      const [x, y] = xy(e);
      
      if (tool === "dodge" || tool === "burn") {
        const radius = size / 2;
        const img = ctx.getImageData(x - radius, y - radius, size, size);
        const data = img.data;
        
        for (let i = 0; i < data.length; i += 4) {
          const px = (i / 4) % size - radius;
          const py = Math.floor((i / 4) / size) - radius;
          const distance = Math.sqrt(px * px + py * py);
          const falloff = Math.max(0, 1 - distance / radius);
          
          const adjustment = (tool === "dodge" ? 30 : -25) * falloff;
          
          for (let j = 0; j < 3; j++) {
            data[i + j] = Math.min(255, Math.max(0, data[i + j] + adjustment));
          }
        }
        
        ctx.putImageData(img, x - radius, y - radius);
        last = [x, y];
        return;
      }
      
      ctx.lineWidth = size;
      ctx.lineTo(x, y);
      ctx.stroke();
      ctx.beginPath();
      ctx.moveTo(x, y);
      last = [x, y];
    };

    canvas.onmouseup = canvas.onmouseleave = () => {
      if (drawing) {
        drawing = false;
        ctx.globalCompositeOperation = "source-over";
        ctx.globalAlpha = 1;
      }
    };

    // Touch events
    canvas.ontouchstart = e => {
      e.preventDefault();
      const [x, y] = xy(e);
      
      if (tool === "fill") {
        pushUndo();
        smartFillPerceptual(x, y, color, fillTolerance, +smoothSlider.value);
        return;
      }
      
      if (tool === "magicWand") {
        magicWandPerceptual(x, y, fillTolerance);
        return;
      }
      
      drawing = true;
      last = [x, y];
      ctx.beginPath();
      ctx.moveTo(x, y);
      ctx.lineWidth = size;
      ctx.lineCap = ctx.lineJoin = "round";
      
      if (tool === "eraser") {
        ctx.globalCompositeOperation = "destination-out";
        ctx.strokeStyle = "rgba(0,0,0,1)";
      } else {
        ctx.globalCompositeOperation = "source-over";
        ctx.strokeStyle = color;
      }
      
      ctx.globalAlpha = tool === "brush" ? 0.97 : 1;
      pushUndo();
    };

    canvas.ontouchmove = e => {
      e.preventDefault();
      if (!drawing) return;
      
      const [x, y] = xy(e);
      ctx.lineTo(x, y);
      ctx.stroke();
      ctx.beginPath();
      ctx.moveTo(x, y);
      last = [x, y];
    };

    canvas.ontouchend = e => {
      e.preventDefault();
      if (drawing) {
        drawing = false;
        ctx.globalCompositeOperation = "source-over";
        ctx.globalAlpha = 1;
      }
    };

    // --- TOOL SWITCHING ---
    toolBrush.onclick = () => setToolUI("brush");
    toolEraser.onclick = () => setToolUI("eraser");
    toolFill.onclick = () => setToolUI("fill");
    magicWandBtn.onclick = () => setToolUI("magicWand");

    // --- CANVAS OPERATIONS ---
    clearBtn.onclick = () => {
      if (confirm("Clear the entire canvas? This cannot be undone.")) {
        pushUndo();
        ctx.clearRect(0, 0, canvas.width, canvas.height);
        ctx.fillStyle = "#fff";
        ctx.fillRect(0, 0, canvas.width, canvas.height);
        setSelectionMask(null);
        showTip("üóëÔ∏è Canvas cleared!");
      }
    };

    // --- SAVE WITH CLEAN EXPORT ---
    saveBtn.onclick = () => {
      const exportCanvas = document.createElement('canvas');
      exportCanvas.width = canvas.width;
      exportCanvas.height = canvas.height;
      const exportCtx = exportCanvas.getContext('2d');
      
      exportCtx.fillStyle = "#ffffff";
      exportCtx.fillRect(0, 0, exportCanvas.width, exportCanvas.height);
      
      const imageData = ctx.getImageData(0, 0, canvas.width, canvas.height);
      const cleanData = new Uint8ClampedArray(imageData.data);
      
      for (let i = 0; i < cleanData.length; i += 4) {
        if (cleanData[i + 3] < 255 && cleanData[i + 3] > 0) {
          cleanData[i + 3] = 255;
        }
      }
      
      const cleanImageData = new ImageData(cleanData, canvas.width, canvas.height);
      exportCtx.putImageData(cleanImageData, 0, 0);
      
      const link = document.createElement("a");
      link.href = exportCanvas.toDataURL("image/png");
      link.download = `ultra-paint-pro-${Date.now()}.png`;
      link.click();
      
      showTip("üíæ High-quality image saved!");
    };

    // --- IMAGE IMPORT ---
    importBtn.onclick = () => importInput.click();

    importInput.onchange = e => {
      const file = e.target.files[0];
      if (!file) return;
      
      showLoading();
      const reader = new FileReader();
      reader.onload = ev => {
        const img = new Image();
        img.onload = function() {
          pushUndo();
          
          const maxWidth = canvas.width;
          const maxHeight = canvas.height;
          let { width, height } = img;
          
          if (width > maxWidth || height > maxHeight) {
            const aspectRatio = width / height;
            if (width > height) {
              width = maxWidth;
              height = width / aspectRatio;
              if (height > maxHeight) {
                height = maxHeight;
                width = height * aspectRatio;
              }
            } else {
              height = maxHeight;
              width = height * aspectRatio;
              if (width > maxWidth) {
                width = maxWidth;
                height = width / aspectRatio;
              }
            }
          }
          
          const x = (canvas.width - width) / 2;
          const y = (canvas.height - height) / 2;
          
          ctx.fillStyle = "#ffffff";
          ctx.fillRect(0, 0, canvas.width, canvas.height);
          ctx.drawImage(img, x, y, width, height);
          hideLoading();
          showTip("üì∑ Image imported and fitted!");
        };
        img.src = ev.target.result;
      };
      reader.readAsDataURL(file);
    };

    // --- UNDO/REDO BUTTONS ---
    undoBtn.onclick = popUndo;
    redoBtn.onclick = popRedo;

    // --- AUTO ENHANCE ---
    document.getElementById("autoEnhanceBtn").onclick = () => {
      pushUndo();
      showLoading();
      setTimeout(() => {
        autoEnhanceAdvanced();
        hideLoading();
        showTip("‚ú® Advanced auto enhancement applied!");
      }, 10);
    };

    function autoEnhanceAdvanced() {
      const img = ctx.getImageData(0, 0, canvas.width, canvas.height);
      const data = img.data;
      
      const histogram = { r: new Array(256).fill(0), g: new Array(256).fill(0), b: new Array(256).fill(0) };
      let pixelCount = 0;
      
      for (let i = 0; i < data.length; i += 4) {
        if (data[i + 3] > 0) {
          histogram.r[data[i]]++;
          histogram.g[data[i + 1]]++;
          histogram.b[data[i + 2]]++;
          pixelCount++;
        }
      }
      
      function findRange(hist) {
        const total = pixelCount;
        const cutoff = total * 0.01;
        
        let min = 0, max = 255;
        let sum = 0;
        
        for (let i = 0; i < 256; i++) {
          sum += hist[i];
          if (sum > cutoff && min === 0) min = i;
        }
        
        sum = 0;
        for (let i = 255; i >= 0; i--) {
          sum += hist[i];
          if (sum > cutoff) { max = i; break; }
        }
        
        return { min, max };
      }
      
      const ranges = {
        r: findRange(histogram.r),
        g: findRange(histogram.g),
        b: findRange(histogram.b)
      };
      
      for (let i = 0; i < data.length; i += 4) {
        if (data[i + 3] > 0) {
          ['r', 'g', 'b'].forEach((channel, idx) => {
            const range = ranges[channel];
            const oldVal = data[i + idx];
            const newVal = ((oldVal - range.min) / (range.max - range.min)) * 255;
            data[i + idx] = Math.min(255, Math.max(0, newVal));
          });
        }
      }
      
      ctx.putImageData(img, 0, 0);
    }

    // --- REMOVE BACKGROUND ---
    document.getElementById("removeBgBtn").onclick = () => {
      pushUndo();
      showLoading();
      setTimeout(() => {
        intelligentBackgroundRemoval();
        hideLoading();
        showTip("üß¨ Background intelligently removed!");
      }, 10);
    };

    function intelligentBackgroundRemoval() {
      const img = ctx.getImageData(0, 0, canvas.width, canvas.height);
      const data = img.data;
      const w = canvas.width;
      const h = canvas.height;
      
      const edgePixels = [];
      const sampleSize = 20;
      
      for (let x = 0; x < w; x += Math.max(1, Math.floor(w / sampleSize))) {
        edgePixels.push([data[x * 4], data[x * 4 + 1], data[x * 4 + 2]]);
        edgePixels.push([data[((h - 1) * w + x) * 4], data[((h - 1) * w + x) * 4 + 1], data[((h - 1) * w + x) * 4 + 2]]);
      }
      
      for (let y = 0; y < h; y += Math.max(1, Math.floor(h / sampleSize))) {
        edgePixels.push([data[y * w * 4], data[y * w * 4 + 1], data[y * w * 4 + 2]]);
        edgePixels.push([data[(y * w + w - 1) * 4], data[(y * w + w - 1) * 4 + 1], data[(y * w + w - 1) * 4 + 2]]);
      }
      
      const bgColor = findDominantColor(edgePixels);
      
      const tolerance = 40;
      for (let i = 0; i < data.length; i += 4) {
        const distance = perceptualColorDistance(
          data[i], data[i + 1], data[i + 2],
          bgColor[0], bgColor[1], bgColor[2]
        );
        
        if (distance < tolerance) {
          data[i + 3] = 0;
        }
      }
      
      ctx.putImageData(img, 0, 0);
    }

    function findDominantColor(pixels) {
      const colorCounts = new Map();
      
      pixels.forEach(([r, g, b]) => {
        const qr = Math.round(r / 16) * 16;
        const qg = Math.round(g / 16) * 16;
        const qb = Math.round(b / 16) * 16;
        const key = `${qr},${qg},${qb}`;
        
        colorCounts.set(key, (colorCounts.get(key) || 0) + 1);
      });
      
      let maxCount = 0;
      let dominantColor = [255, 255, 255];
      
      for (const [key, count] of colorCounts) {
        if (count > maxCount) {
          maxCount = count;
          dominantColor = key.split(',').map(Number);
        }
      }
      
      return dominantColor;
    }

    // --- KEYBOARD SHORTCUTS ---
    document.addEventListener("keydown", e => {
      if (e.ctrlKey && e.key === "z") {
        e.preventDefault();
        popUndo();
      } else if (e.ctrlKey && e.key === "y") {
        e.preventDefault();
        popRedo();
      } else if (!e.ctrlKey && !e.altKey) {
        switch (e.key.toLowerCase()) {
          case "b": setToolUI("brush"); break;
          case "e": setToolUI("eraser"); break;
          case "f": setToolUI("fill"); break;
          case "w": setToolUI("magicWand"); break;
          case "d": setToolUI("dodge"); break;
          case "u": setToolUI("burn"); break;
        }
      }
    });

    // --- HELPER FUNCTIONS ---
    function hexToRgb(hex) {
      hex = hex.replace('#', '');
      if (hex.length === 3) {
        hex = hex[0] + hex[0] + hex[1] + hex[1] + hex[2] + hex[2];
      }
      const x = parseInt(hex, 16);
      return [x >> 16 & 255, x >> 8 & 255, x & 255];
    }

    function rgbToHex(r, g, b) {
      return '#' + [r, g, b].map(x => Math.round(x).toString(16).padStart(2, '0')).join('');
    }

    function clamp(v, a, b) {
      return Math.max(a, Math.min(b, v));
    }

    // --- INITIALIZATION ---
    window.onload = function() {
      ctx.fillStyle = "#ffffff";
      ctx.fillRect(0, 0, canvas.width, canvas.height);
      
      updateHarmonies();
      setToolUI("brush");
      updateButtonStates();
      initTooltips();
      fitCanvasToScreen();
      updateSelectionCanvasPosition();
      
      setTimeout(showOnboarding, 500);
      
      setTimeout(() => {
        showTip("üé® Welcome! Magic Wand (‚≠ê) now shows marching ants selection!");
      }, 1000);
      
      window.addEventListener('resize', () => {
        setTimeout(() => {
          fitCanvasToScreen();
          updateSelectionCanvasPosition();
        }, 100);
      });
    };
  </script>
</body>
</html>
